From 836249c3db2be9c01c2d34ac1231ba9daf3c5e14 Mon Sep 17 00:00:00 2001
From: Kai Jones <zaksenoj@icloud.com>
Date: Sat, 14 Dec 2019 23:38:51 -0800
Subject: [PATCH] mt8163: add required changes for mediatek

Change-Id: Iff2d66b32869d27b6e65b0d8df4bf302b33ca892
Signed-off-by: Kai Jones <zaksenoj@icloud.com>
---
 init/init.cpp         | 14 +++++++--
 init/init.h           |  2 +-
 init/service.cpp      |  3 ++
 libcutils/Android.mk  |  3 +-
 liblog/logger_write.c | 66 ++++++++++++++++++++++++++++++++++---------
 5 files changed, 70 insertions(+), 18 deletions(-)
 mode change 100644 => 100755 init/init.h

diff --git a/init/init.cpp b/init/init.cpp
index 7a370596e..dd987d4c8 100755
--- a/init/init.cpp
+++ b/init/init.cpp
@@ -85,7 +85,9 @@ int have_console;
 std::string console_name = "/dev/console";
 static time_t process_needs_restart;
 
-const char *ENV[32];
+// xen0n: some MTK services (e.g. ril-daemon-mtk) require very large number
+// of sockets, which can't be contained in 32 entries minus other variables.
+const char *ENV[64];
 
 bool waiting_for_exec = false;
 
@@ -367,6 +369,12 @@ static void export_kernel_boot_props() {
         { "ro.boot.baseband",   "ro.baseband",   "unknown", },
         { "ro.boot.bootloader", "ro.bootloader", "unknown", },
         { "ro.boot.hardware",   "ro.hardware",   "unknown", },
+#ifdef MTK_MT8163
+        { "ro.boot.hardware",   "ro.hardware",   "mt8163", },
+#endif
+#ifdef MTK_MT8173
+        { "ro.boot.hardware",   "ro.hardware",   "mt8173", },
+#endif
 #ifndef IGNORE_RO_BOOT_REVISION
         { "ro.boot.revision",   "ro.revision",   "0", },
 #endif
@@ -440,6 +448,7 @@ static void selinux_init_all_handles(void)
     sehandle_prop = selinux_android_prop_context_handle();
 }
 
+#if 0
 enum selinux_enforcing_status { SELINUX_PERMISSIVE, SELINUX_ENFORCING };
 
 static selinux_enforcing_status selinux_status_from_cmdline() {
@@ -453,11 +462,12 @@ static selinux_enforcing_status selinux_status_from_cmdline() {
 
     return status;
 }
+#endif
 
 static bool selinux_is_enforcing(void)
 {
     if (ALLOW_PERMISSIVE_SELINUX) {
-        return selinux_status_from_cmdline() == SELINUX_ENFORCING;
+        return false;  // selinux_status_from_cmdline() == SELINUX_ENFORCING;
     }
     return true;
 }
diff --git a/init/init.h b/init/init.h
old mode 100644
new mode 100755
index 345d442c0..f93d0c5ba
--- a/init/init.h
+++ b/init/init.h
@@ -24,7 +24,7 @@ class Service;
 
 #define COMMAND_RETRY_TIMEOUT 5
 
-extern const char *ENV[32];
+extern const char *ENV[64];
 extern bool waiting_for_exec;
 extern int have_console;
 extern std::string console_name;
diff --git a/init/service.cpp b/init/service.cpp
index 8127e708d..eb4df4765 100644
--- a/init/service.cpp
+++ b/init/service.cpp
@@ -371,6 +371,7 @@ bool Service::Start() {
             scon = ret_scon;
             free(ret_scon);
         }
+#if 0
         if (rc == 0 && scon == mycon) {
             ERROR("Service %s does not have a SELinux domain defined.\n", name_.c_str());
             if (selinux_status_getenforce() > 0) {
@@ -380,6 +381,7 @@ bool Service::Start() {
             }
 
         }
+#endif
         free(mycon);
         free(fcon);
         if (rc < 0) {
diff --git a/libcutils/Android.mk b/libcutils/Android.mk
index 7a922539f..c168f3235 100644
--- a/libcutils/Android.mk
+++ b/libcutils/Android.mk
@@ -101,7 +101,8 @@ LOCAL_SRC_FILES := $(libcutils_common_sources) \
         properties.c \
         qtaguid.c \
         trace-dev.c \
-        uevent.c \
+        uevent.c 
+
 
 LOCAL_SRC_FILES_arm += arch-arm/memset32.S
 LOCAL_SRC_FILES_arm64 += arch-arm64/android_memset.S
diff --git a/liblog/logger_write.c b/liblog/logger_write.c
index c7b5a8415..0ef5eb10f 100644
--- a/liblog/logger_write.c
+++ b/liblog/logger_write.c
@@ -35,6 +35,10 @@
 #include "log_portability.h"
 #include "logger.h"
 
+#ifndef FAKE_LOG_DEVICE
+#include <sys/system_properties.h>
+#endif
+
 #define LOG_BUF_SIZE 1024
 
 static int __write_to_log_init(log_id_t, struct iovec *vec, size_t nr);
@@ -389,27 +393,36 @@ LIBLOG_ABI_PUBLIC int __android_log_buf_write(int bufID, int prio,
                                               const char *tag, const char *msg)
 {
     struct iovec vec[3];
-    char tmp_tag[32];
+    char tmp_tag[32]="0";
 
     if (!tag)
         tag = "";
 
     /* XXX: This needs to go! */
     if ((bufID != LOG_ID_RADIO) &&
-         (!strcmp(tag, "HTC_RIL") ||
-        !strncmp(tag, "RIL", 3) || /* Any log tag with "RIL" as the prefix */
-        !strncmp(tag, "IMS", 3) || /* Any log tag with "IMS" as the prefix */
-        !strcmp(tag, "AT") ||
-        !strcmp(tag, "GSM") ||
-        !strcmp(tag, "STK") ||
-        !strcmp(tag, "CDMA") ||
-        !strcmp(tag, "PHONE") ||
-        !strcmp(tag, "SMS"))) {
-            bufID = LOG_ID_RADIO;
-            /* Inform third party apps/ril/radio.. to use Rlog or RLOG */
-            snprintf(tmp_tag, sizeof(tmp_tag), "use-Rlog/RLOG-%s", tag);
-            tag = tmp_tag;
+	(!strcmp(tag, "HTC_RIL") ||
+	 !strncmp(tag, "RIL", 3) || /* Any log tag with "RIL" as the prefix */
+	 !strncmp(tag, "IMS", 3) || /* Any log tag with "IMS" as the prefix */
+	 !strcmp(tag, "AT") ||
+	 !strcmp(tag, "GSM") ||
+	 !strcmp(tag, "STK") ||
+	 !strcmp(tag, "CDMA") ||
+	 !strcmp(tag, "PHONE") ||
+	 !strcmp(tag, "SMS"))) {
+	bufID = LOG_ID_RADIO;
+	/* Inform third party apps/ril/radio.. to use Rlog or RLOG */
+	snprintf(tmp_tag, sizeof(tmp_tag), "use-Rlog/RLOG-%s", tag);
+	tag = tmp_tag;
+    }
+
+#ifndef FAKE_LOG_DEVICE
+    /* check property for moving all RIL logs to main */
+    if (bufID == LOG_ID_RADIO) {
+	if ((__system_property_get("persist.ril.log",tmp_tag) > 0) &&
+		!strcmp(tmp_tag,"1"))
+	    bufID = LOG_ID_MAIN;
     }
+#endif
 
 #if __BIONIC__
     if (prio == ANDROID_LOG_FATAL) {
@@ -581,3 +594,28 @@ LIBLOG_ABI_PUBLIC int __android_log_security_bswrite(int32_t tag,
 
     return write_to_log(LOG_ID_SECURITY, vec, 4);
 }
+#ifdef MTK_HARDWARE
+#ifndef __unused
+#define __unused  __attribute__((__unused__))
+#endif
+struct xlog_record {
+    const char *tag_str;
+    const char *fmt_str;
+    int prio;
+};
+
+LIBLOG_ABI_PUBLIC void __attribute__((weak)) __xlog_buf_printf(int bufid __unused, const struct xlog_record *xlog_record __unused, ...) {
+#ifndef FAKE_LOG_DEVICE
+    char prop[32]="0";
+    /* check property for diable all xlog */
+    __system_property_get("ro.disable.xlog",prop);
+    if (!strcmp(prop, "0"))
+#endif
+    {
+	va_list args;
+	va_start(args, xlog_record);
+	__android_log_vprint(xlog_record->prio, xlog_record->tag_str, xlog_record->fmt_str, args);
+    }
+}
+#endif
+
-- 
2.25.0

